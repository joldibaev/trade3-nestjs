# DocumentPurchaseService (Закупки)

Этот сервис отвечает за создание и управление документами закупки товаров у поставщиков.

## Методы

### `create(dto: CreateDocumentPurchaseDto)`

Создает заголовок документа закупки.

- **Status**: По умолчанию `DRAFT`.
- **Code**: Генерируется автоматически с префиксом `P-`.
- **Items**: В этом методе **не передаются**. Товары добавляются после создания документа через `addItems`.

1.  **Валидация**: Проверяет существование склада (`storeId`).
2.  **Запись**: Создает `DocumentPurchase` с суммой 0.
3.  **Логирование**: Записывает действие `CREATED` в `DocumentLedger`.

### `update(id: string, dto: UpdateDocumentPurchaseDto)`

Обновляет заголовочные данные документа (склад, поставщик, дата, примечания).

- **Ограничение**: Доступно только в статусе `DRAFT`.
- **Логика**: При изменении данных записывает `UPDATED` в `DocumentLedger` с деталями изменений.
- **Позиции**: Позиции товаров в этом методе **не обновляются**.

### `addItems(id: string, dto: CreateDocumentPurchaseItemsDto)`

Добавляет новые товары в документ.

- **Ограничение**: Доступно только в статусе `DRAFT`.
- **Payload**: `{ items: CreateDocumentPurchaseItemDto[] }`

1. **Итерация**: Проходит по всем переданным позициям.
2. **Расчет**: Вычисляет `total` позиции (`quantity * price`).
3. **Создание**: Добавляет запись в `DocumentPurchaseItem`.
4. **Цены**: Если переданы `newPrices`, синхронизирует их со связанным документом `DocumentPriceChange`.
5. **Логирование**: Записывает `ITEM_ADDED` в `DocumentLedger` для каждой позиции.
6. **Итог**: Обновляет общую сумму документа (`total`).

### `updateItem(id: string, productId: string, dto: CreateDocumentPurchaseItemDto)`

Обновляет существующую позицию в документе.

- **Ограничение**: Доступно только в статусе `DRAFT`.

1. **Пересчет**: Вычисляет новую сумму позиции.
2. **Обновление**: Изменяет `quantity` и `price` в `DocumentPurchaseItem`.
3. **Итог**: Обновляет общую сумму документа (`total`) путем вычитания старой суммы позиции и прибавления новой.
4. **Цены**: Синхронизирует `newPrices`.
5. **Логирование**: Записывает `DIFF` изменений позиции в `DocumentLedger`.

### `removeItems(id: string, dto: RemoveDocumentPurchaseItemsDto)`

Удаляет позиции из документа.

- **Ограничение**: Доступно только в статусе `DRAFT`.
- **Payload**: `{ productIds: string[] }`

1. **Удаление**: Удаляет записи из `DocumentPurchaseItem` по списку `productIds`.
2. **Итог**: Уменьшает общую сумму документа (`total`) на сумму удаленных позиций.
3. **Цены**: Если удаленные товары имели `newPrices`, они удаляются из связанного `DocumentPriceChange`.
4. **Логирование**: Записывает `ITEM_REMOVED` в `DocumentLedger` для каждой удаленной позиции.

### `findAll(include?)`

Возвращает список всех закупок.

- **Сортировка**: От новых к старым (`createdAt: 'desc'`).
- **Параметры**: Позволяет через `include` подгрузить связанные данные (склад, поставщик, позиции).

### `updateStatus(id: string, newStatus: 'DRAFT' | 'COMPLETED' | 'CANCELLED')`

Этот метод управляет изменением статуса документа закупки (например, проведение или отмена) и выполняет всю связанную бизнес-логику в рамках транзакции.

Вот что происходит по шагам:

1.  **Транзакция (`isolationLevel: 'Serializable'`)**:
    - Весь процесс обернут в строгую транзакцию для защиты от гонки данных при пересчете остатков и себестоимости.

2.  **Загрузка данных**:
    - Получает документ со всеми позициями (`items`).
    - Если статус не меняется, просто возвращает документ.

3.  **Валидация**:
    - Запрещает изменение статуса, если документ уже `CANCELLED` (Отменен).

4.  **Сценарий: Проведение (DRAFT -> COMPLETED)**:
    - **Движение товара**: Вызывает `applyInventoryMovements`, который:
      - Увеличивает остаток на складе (`Stock`).
      - Пересчитывает средневзвешенную цену закупки (WAP).

      - Создает запись в истории движений (`StockLedger`) с типом `PURCHASE`.

    - **Future Date**: Если дата в будущем, статус станет `SCHEDULED`. Движения не выполняются.

5.  **Сценарий: Отмена проведения (COMPLETED -> DRAFT / CANCELLED)**:
    - **Проверка стока**: `validateStockForRevert` проверяет, достаточно ли товара на складе для отмены (не ушел ли он уже в минус) и не станет ли стоимость склада отрицательной.
    - **Откат движения**: Вызывает `applyInventoryMovements` с **отрицательным количеством**, чтобы:
      - Уменьшить остаток.
      - Скорректировать WAP (удалить влияние этой закупки).
    - **Подготовка к пересчету**: Собирает список товаров (`itemsToReprocess`), историю которых нужно пересчитать, так как изменение старой закупки влияет на себестоимость будущих продаж.

6.  **Обновление статуса**:
    - Меняет статус самого документа в БД.

7.  **Пересчет истории (Sequence Reprocessing)**:
    - Выполняется **после** завершения основной транзакции (чтобы не блокировать базу надолго).
    - Если документ занесен задним числом или его статус изменен с `COMPLETED`, автоматически создается системный документ `InventoryReprocessing`.
    - Для каждого затронутого товара вызывает `inventoryService.reprocessProductHistory`, который хронологически пересчитывает WAP и остатки всех последующих операций.
    - Итоговые изменения (старые и новые значения) логируются в `InventoryReprocessingItem` для полного аудита.

Таким образом, метод гарантирует корректность остатков, цен и истории даже при исправлении ошибок в документах за прошлые периоды.

## Особенности

- **Изоляция**: Используется уровень `Serializable`, чтобы гарантировать, что параллельные закупки одного и того же товара правильно пересчитают WAP.
- **Интеграция**: Плотно взаимодействует с `InventoryService` для валидации и логирования аудита.
