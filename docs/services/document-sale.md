# DocumentSaleService (Продажи)

Этот сервис отвечает за реализацию товара клиентам через кассы.

## Методы

### `create(dto: CreateDocumentSaleDto)`
Создает документ продажи.
*   **Items**: Опциональны.
*   **Status**: По умолчанию `DRAFT`.

1.  **Валидация склада**: Проверка `storeId`.
2.  **Транзакция** (`ReadCommitted`):
    *   Создает `DocumentSale`.
    *   Если передан статус `COMPLETED`, выполняет списание (проверка остатков, фиксация себестоимости, аудит).

### `update(id: string, dto: CreateDocumentSaleDto)`
Полное обновление документа (замена позиций).
*   **Ограничение**: Только для статуса **DRAFT**.
*   **Логика**: Старые позиции удаляются, новые создаются. Цены пересчитываются заново.

### `remove(id: string)`
Удаление документа.
*   **Ограничение**: Только для статуса **DRAFT**.

### `findAll(include?)`
Возвращает список продаж с сортировкой по дате создания (новые сверху).

### `updateStatus(id: string, newStatus: 'DRAFT' | 'COMPLETED' | 'CANCELLED')`
Управление статусом продажи.
*   **DRAFT -> COMPLETED**: Проводит продажу. Списывает товар, фиксирует себестоимость (`updateItemCostPrices`) для расчета прибыли.
*   **COMPLETED -> DRAFT / CANCELLED**: Отменяет продажу (например, возврат чека).
    *   **Действие**: Возвращает списанный товар обратно на склад. Увеличивает `quantity` в таблице `Stock`.
    *   **Особенность**: Это безопасная операция, так как возвращает физический товар. Не требует пересчета WAP (так как продажа его не меняла).
    *   **Идемпотентность**: Повторный вызов с тем же статусом не делает ничего.

## Особенности
*   **WAP**: Продажа **никогда не меняет** себестоимость товара в таблице `Stock`. Она только считывает её для фиксации маржинальности конкретной сделки.
*   **Sequence Reprocessing**: Если документ закупки, определивший себестоимость этой продажи, будет отменен или изменен в будущем, система **автоматически обновит** поле `costPrice` в этой продаже. Это гарантирует, что отчет о прибыли всегда будет актуален, даже при исправлении ошибок "задним числом".
*   **Атомарность**: Использование `updateMany` с проверкой условия количества гарантирует, что даже вне Serializable транзакции остаток не станет отрицательным.
