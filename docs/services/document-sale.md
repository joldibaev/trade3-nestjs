# DocumentSaleService (Продажи)

Этот сервис отвечает за реализацию товара клиентам через кассы.

## Методы

### `create(dto: CreateDocumentSaleDto)`

Создает документ продажи.

Создает заголовок продажи.

### `update(id: string, dto: CreateDocumentSaleDto)`

Обновление заголовка (склад, касса, клиент, тип цены и т.д.).

### `addItem(id: string, dto: CreateDocumentSaleItemDto)`

Добавляет товар.

- Если цена не указана, она автоматически подтягивается из справочника цен согласно `priceTypeId` документа.
- Фиксирует `costPrice` (на основе WAP из остатков) на момент добавления.
- Обновляет `total` документа.

### `updateItem(id: string, itemId: string, dto: CreateDocumentSaleItemDto)`

Обновляет количество или цену. Корректирует `total`.

### `removeItem(id: string, itemId: string)`

Удаляет товар, корректирует `total`.

- **Ограничение**: Только для статуса **DRAFT**.
- **Логика**: Старые позиции удаляются, новые создаются. Цены пересчитываются заново.

### `findAll(include?)`

Возвращает список продаж с сортировкой по дате создания (новые сверху).

### `updateStatus(id: string, newStatus: 'DRAFT' | 'COMPLETED' | 'CANCELLED')`

Управление статусом продажи.

- **DRAFT -> COMPLETED**: Проводит продажу. Списывает товар.
  - Если дата в будущем, статус станет `SCHEDULED`.
- **COMPLETED -> DRAFT / CANCELLED**: Отменяет продажу (например, возврат чека).
  - **Действие**: Возвращает списанный товар обратно на склад. Увеличивает `quantity` в таблице `Stock`.
  - **Пересчет**: Отмена продажи всегда инициирует [пересчет истории](../entities.md#inventoryreprocessing-пересчет-истории), так как это влияет на остатки будущих периодов.
  - **Идемпотентность**: Повторный вызов с тем же статусом не делает ничего.

## Особенности

- **WAP**: Продажа **никогда не меняет** себестоимость товара в таблице `Stock`. Она только считывает её для фиксации маржинальности конкретной сделки.
- **Sequence Reprocessing**: Система автоматически отслеживает изменения в "прошлом". Если продажа создана задним числом или отменена, создается документ `InventoryReprocessing`, и все последующие движения товара пересчитываются для поддержания корректных остатков и (при необходимости) каскадного обновления `costPrice` в продажах. Это гарантирует, что отчет о прибыли всегда будет актуален.
- **Атомарность**: Использование `updateMany` с проверкой условия количества гарантирует, что даже вне Serializable транзакции остаток не станет отрицательным.
