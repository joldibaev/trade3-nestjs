# DocumentSaleService (Продажи)

Этот сервис отвечает за реализацию товара клиентам через кассы.

## Методы

### `create(dto: CreateDocumentSaleDto)`
Создает документ продажи.
*   **Items**: Опциональны.
*   **Status**: По умолчанию `DRAFT`.

1.  **Валидация склада**: Проверка `storeId`.
2.  **Транзакция** (`ReadCommitted`):
    *   Создает `DocumentSale`.
    *   Если передан статус `COMPLETED`, выполняет списание.
    *   **Авто-планирование**: Если дата документа в будущем, статус принудительно меняется на `SCHEDULED`. Списание произойдет автоматически при наступлении даты.

### `update(id: string, dto: CreateDocumentSaleDto)`
Полное обновление документа (замена позиций).
*   **Ограничение**: Только для статуса **DRAFT**.
*   **Логика**: Старые позиции удаляются, новые создаются. Цены пересчитываются заново.

### `remove(id: string)`
Удаление документа.
*   **Ограничение**: Только для статуса **DRAFT**.

### `findAll(include?)`
Возвращает список продаж с сортировкой по дате создания (новые сверху).

### `updateStatus(id: string, newStatus: 'DRAFT' | 'COMPLETED' | 'CANCELLED')`
Управление статусом продажи.
*   **DRAFT -> COMPLETED**: Проводит продажу. Списывает товар.
    *   Если дата в будущем, статус станет `SCHEDULED`.
*   **COMPLETED -> DRAFT / CANCELLED**: Отменяет продажу (например, возврат чека).
    *   **Действие**: Возвращает списанный товар обратно на склад. Увеличивает `quantity` в таблице `Stock`.
    *   **Пересчет**: Отмена продажи всегда инициирует [пересчет истории](../entities.md#inventoryreprocessing-пересчет-истории), так как это влияет на остатки будущих периодов.
    *   **Идемпотентность**: Повторный вызов с тем же статусом не делает ничего.

## Особенности
*   **WAP**: Продажа **никогда не меняет** себестоимость товара в таблице `Stock`. Она только считывает её для фиксации маржинальности конкретной сделки.
*   **Sequence Reprocessing**: Система автоматически отслеживает изменения в "прошлом". Если продажа создана задним числом или отменена, создается документ `InventoryReprocessing`, и все последующие движения товара пересчитываются для поддержания корректных остатков и (при необходимости) каскадного обновления `costPrice` в продажах. Это гарантирует, что отчет о прибыли всегда будет актуален.
*   **Атомарность**: Использование `updateMany` с проверкой условия количества гарантирует, что даже вне Serializable транзакции остаток не станет отрицательным.
