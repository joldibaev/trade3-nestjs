# Аутентификация и Авторизация

В системе реализована защищенная аутентификация на базе JWT (JSON Web Tokens).

## Обзор системы

Система использует подход с двумя токенами:
1.  **Access Token**: Короткоживущий токен доступа (передается в заголовке `Authorization`).
2.  **Refresh Token**: Долгоживущий токен для обновления (хранится в защищенной `HttpOnly` cookie).

Все маршруты API защищены по умолчанию с помощью глобального `JwtAuthGuard`.

## API Эндпоинты (`/auth`)

| Метод | Путь | Описание | Доступ |
| :--- | :--- | :--- | :--- |
| `POST` | `/auth/register` | Регистрация нового пользователя. | Публичный |
| `POST` | `/auth/login` | Вход: проверяет email/пароль, выдает AccessToken в теле ответа и RefreshToken в Cookie. | Публичный (`LocalAuthGuard`) |
| `POST` | `/auth/logout` | Выход: удаляет RefreshToken из БД и очищает Cookie. | Приватный (`JwtAuthGuard`) |
| `POST` | `/auth/refresh` | Обновление: выдает новую пару токенов на основе валидной Refresh-cookie. | Публичный (`JwtRefreshGuard`) |

## Как использовать

### Защита маршрутов
Все контроллеры защищены глобально. Чтобы сделать маршрут приватным, ничего делать не нужно. Данные пользователя доступны через `req.user`.

### Открытие публичного доступа: `@Public()`
Если эндпоинт должен быть открыт для всех (например, документация или health-check), используйте декоратор `@Public()`.

```typescript
import { Public } from '../../common/decorators/public.decorator';

@Public()
@Get('status')
getStatus() {
  return { ok: true };
}
```

### Роли и доступ
Пользовательская роль (`USER`, `ADMIN`) хранится в токене. В сервисах можно получить роль через `req.user.role`.

## Безопасность

- **HttpOnly & SameSite**: Cookies настроены так, чтобы предотвратить XSS и CSRF атаки.
- **Хеширование**: Пароли никогда не хранятся в открытом виде (используется `bcrypt`).
- **Инвалидация**: При логауте Refresh Token удаляется из базы данных, что предотвращает его повторное использование.

## Тестирование (E2E)

В проекте реализован механизм **Bypass** для удобства написания интеграционных тестов:
- Если `NODE_ENV === 'test'` и заголовок `Authorization` **отсутствует**, guard автоматически пропускает запрос. Это позволяет старым тестам (написанным до внедрения аутентификации) работать без изменений.
- Если вы хотите проверить логику 401 Unauthorized в тестах, передайте заголовок `x-test-force-auth: true`.

---
_Дата последнего обновления: 27 января 2026 года_
