# Concurrency Control & Database Integrity

Система складского учета критична к целостности данных. Ошибки в расчетах остатков или себестоимости (WAP) могут привести к финансовых потерям. Этот документ описывает принятую стратегию управления конкурентным доступом.

## Стратегия: Pessimistic Locking с Advisory Locks

Для обеспечения целостности данных при параллельных операциях мы перешли от уровня изоляции `Serializable` к комбинации `ReadCommitted` и явных **Advisory Locks** (Рекомендательные блокировки Postgres).

### Почему мы отказались от `Serializable`?

Изначально использовался уровень `Serializable`, который гарантирует строгую целостность "из коробки". Однако он имеет существенный недостаток при высокой конкуренции:

- **Serialization Failures:** При конфликте транзакций база данных прерывает одну из них, выбрасывая ошибку.
- **Сложность для клиента:** Это требует реализации сложной логики `Retry` (автоматического повтора) на стороне клиента или контроллера.
- **UX:** Пользователи могут получать случайные ошибки при активной работе.

### Текущее решение: `ReadCommitted` + `pg_advisory_xact_lock`

Мы используем уровень изоляции `ReadCommitted`, который является стандартом по умолчанию в Postgres. Чтобы избежать аномалий (Lost Updates, Write Skew) при расчете остатков, мы используем механизм **Advisory Locks**.

#### Как это работает

1.  **Хеширование ключа**: Для каждого товара на складе генерируется уникальный ключ блокировки на основе `storeId` и `productId` (используется функция `hashtext`).
2.  **Захват блокировки (Queue)**: В начале любой транзакции, изменяющей остатки (Продажа, Закупка, Пересчет), мы явно вызываем:
    ```sql
    SELECT pg_advisory_xact_lock(hashtext('store_uuid-product_uuid'));
    ```
3.  **Очередь вместо ошибки**: Если другой процесс уже работает с этим товаром, текущая транзакция **приостанавливается и ждет** (Wait), пока первая не завершится (commit/rollback).
4.  **Гарантия последовательности**: Это превращает параллельные запросы к одному товару в последовательную цепочку. Каждый следующий запрос видит актуальные остатки, оставленные предыдущим.

### Реализация

Механизм инкапсулирован в `InventoryService`:

```typescript
// src/core/inventory/inventory.service.ts
async lockProduct(tx: Prisma.TransactionClient, storeId: string, productId: string) {
  const keyString = `${storeId}-${productId}`;
  await tx.$executeRaw`SELECT pg_advisory_xact_lock(hashtext(${keyString}))`;
}
```

Этот метод **ОБЯЗАН** вызываться в начале любой транзакции (`$transaction`), которая планирует изменять `Stock` или `StockLedger`.

### Пример использования (DocumentSaleService)

```typescript
// src/document-sale/document-sale.service.ts
await this.prisma.$transaction(
  async (tx) => {
    // 1. Сортируем ID во избежание Deadlocks (важно!)
    const sortedProductIds = sortUnique(items.map((i) => i.productId));

    // 2. Блокируем все товары, участвующие в продаже
    for (const pid of sortedProductIds) {
      await this.inventoryService.lockProduct(tx, storeId, pid);
    }

    // 3. Читаем остатки (Stock) - теперь это безопасно
    // 4. Вычисляем (Compute)
    // 5. Обновляем (Update)
  },
  { isolationLevel: 'ReadCommitted' },
);
```

## Преимущества

1.  **Отсутствие случайных ошибок**: Пользователь не получает "Transaction failed" при нормальной работе.
2.  **Корректность данных**: Гарантирует защиту от отрицательных остатков и неверного WAP с той же надежностью, что и `Serializable`.
3.  **Производительность**: Ожидание блокировки для конкурентных товаров дешевле, чем откат и повтор всей транзакции.
