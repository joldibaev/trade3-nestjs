# Concurrency Control & Database Integrity

Система складского учета критична к целостности данных. Ошибки в расчетах остатков или себестоимости (WAP) могут привести к финансовых потерям. Этот документ описывает принятую стратегию управления конкурентным доступом.

## Стратегия: Pessimistic Locking с Advisory Locks

Для обеспечения целостности данных при параллельных операциях мы перешли от уровня изоляции `Serializable` к комбинации `ReadCommitted` и явных **Advisory Locks** (Рекомендательные блокировки Postgres).

### Почему мы отказались от `Serializable`?

Изначально использовался уровень `Serializable`, который гарантирует строгую целостность "из коробки". Однако он имеет существенный недостаток при высокой конкуренции:

- **Serialization Failures:** При конфликте транзакций база данных прерывает одну из них, выбрасывая ошибку.
- **Сложность для клиента:** Это требует реализации сложной логики `Retry` (автоматического повтора) на стороне клиента или контроллера.
- **UX:** Пользователи могут получать случайные ошибки при активной работе.

### Текущее решение: `ReadCommitted` + `pg_advisory_xact_lock`

Мы используем уровень изоляции `ReadCommitted`, который является стандартом по умолчанию в Postgres. Чтобы избежать аномалий (Lost Updates, Write Skew) при расчете остатков, мы используем механизм **Advisory Locks**.

#### Как это работает

1.  **Хеширование ключа**: Для каждого товара на складе генерируется уникальный ключ блокировки на основе `storeId` и `productId` (используется функция `hashtext`).
2.  **Захват блокировки (Queue)**: В начале любой транзакции, изменяющей остатки (Продажа, Закупка, Пересчет), мы вызываем метод пакетной блокировки.
3.  **Очередь вместо ошибки**: Если другой процесс уже работает с этим товаром, текущая транзакция **приостанавливается и ждет** (Wait), пока первая не завершится (commit/rollback).
4.  **Гарантия последовательности**: Это превращает параллельные запросы к одному товару в последовательную цепочку. Каждый следующий запрос видит актуальные остатки, оставленные предыдущим.
5.  **Safety Net**: В качестве дополнительной защиты, метод `InventoryService.applyMovements` также выполняет блокировку товаров. Это гарантирует целостность данных, даже если разработчик забыл вызвать блокировку в сервисе документа.

### Реализация

Механизм управления блокировками инкапсулирован в `InventoryService`:

```typescript
// src/inventory/inventory.service.ts

/**
 * Блокирует один товар на конкретном складе.
 */
async lockProduct(tx: Prisma.TransactionClient, storeId: string, productId: string);

/**
 * Пакетная блокировка (Золотой стандарт).
 * Автоматически дедуплицирует и сортирует ключи во избежание Deadlocks.
 */
async lockInventory(tx: Prisma.TransactionClient, locks: { storeId: string; productId: string }[]);
```

Вызов `lockInventory` **ОБЯЗАН** находиться в самом начале транзакции (`$transaction`), до любых расчетов остатков или себестоимости.

### Пример использования (DocumentSaleService)

```typescript
// src/document-sale/document-sale.service.ts
await this.prisma.$transaction(
  async (tx) => {
    // 1. Блокируем все товары документа (автоматически сортируется внутри сервиса)
    const productIds = items.map((i) => i.productId);
    await this.inventoryService.lockInventory(
      tx,
      productIds.map((pid) => ({ storeId: sale.storeId, productId: pid })),
    );

    // 2. Читаем остатки, обновляем данные и пишем в Ledger
    await this.applyInventoryMovements(tx, sale, items, 'INITIAL');
  },
  { isolationLevel: 'ReadCommitted' },
);
```

### Особый случай: Перемещения (Transfer)

При межскладских перемещениях критически важно блокировать товары **сразу на обоих складах** (отправитель и получатель) в одном вызове `lockInventory`. Это единственный надежный способ избежать взаимной блокировки (Deadlock) двух одновременных встречных перемещений.

## Преимущества

1.  **Отсутствие случайных ошибок**: Пользователь не получает "Transaction failed" при нормальной работе.
2.  **Корректность данных**: Гарантирует защиту от отрицательных остатков и неверного WAP с той же надежностью, что и `Serializable`.
3.  **Производительность**: Ожидание блокировки для конкурентных товаров дешевле, чем откат и повтор всей транзакции.

## Контроль доступности через Бронирование (Reserved)

Помимо блокировок на уровне БД, система использует поле `Stock.reserved` для управления доступностью товара в бизнес-логике.

### Проблема: Race Condition при создании черновика

Без поля `reserved` два менеджера могли одновременно создать черновики продаж на последний товар. Оба черновика были бы валидны, но провести (`COMPLETED`) удалось бы только один.

### Решение: Мгновенное бронирование

1.  **Захват брони**: Как только товар добавляется в `DRAFT` документа (Sale/Transfer), система увеличивает `reserved`.
2.  **Валидация**: Расчет свободного остатка: `quantity - reserved`. Если результат меньше нуля, операция отклоняется.
3.  **Гарантия**: Бронирование выполняется внутри транзакции с использованием `lockInventory`, что исключает ситуацию, когда два процесса одновременно "видят" один и тот же свободный остаток и бронируют его.

### Решение проблемы "Призрачных броней" (Ghost Reservations)

Чтобы брони в забытых черновиках не блокировали товар вечно, реализован автоматический клининг (`SchedulerService`):

- Раз в час Cron-задача проверяет документы в статусе `DRAFT` старше 24 часов.
- Такие документы переводятся в `CANCELLED`.
- Переход статуса автоматически высвобождает бронь в `Stock.reserved`.
